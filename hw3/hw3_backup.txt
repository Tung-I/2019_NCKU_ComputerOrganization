module fpadder (
    input  [31:0] src1,
    input  [31:0] src2,
    output reg [31:0] out
);

  

  reg [31:0] bigNum, smallNum; //to seperate big and small numbers
  wire [22:0] big_fra, small_fra; //to hold fraction part
  wire [7:0] big_ex, small_ex; //to hold exponent part
  wire big_sig, small_sig; //to hold signs

  wire [7:0] ex_diff; //difrence between exponentials
  wire [23:0] small_float, big_float; //with integer 
  reg [23:0] shift_small_float;
  reg [24:0] sign_shift_small_float, sign_big_float; //with sign bit and integer
  reg [24:0] sum; 
  reg [25:0] overflow;
  
  reg[2:0] GRS;
  reg tmp;
  reg [23:0] tmp2;

  reg [7:0] sum_ex;
  reg [22:0] sum_fra;
  reg sum_sig;

  assign {big_sig, big_ex, big_fra} = bigNum;
  assign {small_sig, small_ex, small_fra} = smallNum;
  assign ex_diff = big_ex - small_ex;
  assign big_float = {1'b1, big_fra};
  assign small_float = {1'b1, small_fra};

 

  always@(src1 or src2) //determine big number
    begin
      if(src2[30:23] > src1[30:23])
        begin
          bigNum = src2;
          smallNum = src1;
        end
      else if(src2[30:23] == src1[30:23])
        begin
          if(src2[22:0] > src1[22:0])
            begin
              bigNum = src2;
              smallNum = src1;
            end
          else
            begin
              bigNum = src1;
              smallNum = src2;
            end
        end
      else
        begin
          bigNum = src1;
          smallNum = src2;
        end
    end

  always@(ex_diff or small_float) //shift the smaller one
    begin
      case(ex_diff)
	0: GRS = 3'b0;
	1: begin GRS = 3'b0; 
           GRS[2] = small_float[0]; end
	2: begin GRS = 3'b0; 
           GRS[2] = small_float[1];
	   GRS[1] = small_float[0]; end
	default: begin GRS[2] = small_float[ex_diff-1];
	         GRS[1] = small_float[ex_diff-2];
		 tmp2 = small_float;
	         tmp2 = tmp2 << (24 - ex_diff + 2);
	         GRS[0] = (tmp2==0)?0:1; end
      endcase 
      shift_small_float = (small_float >> ex_diff);
      sum_ex = big_ex;
      if(GRS>3'b100)
	begin
	  shift_small_float = shift_small_float + 1;
	end
      else if(GRS==3'b100)
	begin
	  case(shift_small_float[0])
	    1: shift_small_float = shift_small_float + 1;
	    default: shift_small_float = shift_small_float; 
	  endcase
	end
      else
	begin
	end
    end

  always@(shift_small_float or big_float) //add the sign bit
    begin
      if(big_sig==1)
        begin
	  sign_big_float = ~{1'b0, big_float} + 25'b1;
	end
      else
	begin
	  sign_big_float = {1'b0, big_float};
	end
      if(small_sig==1)
	begin
	  sign_shift_small_float = ~{1'b0, shift_small_float} + 25'b1;
	end
      else
	begin
	  sign_shift_small_float = {1'b0, shift_small_float};
	end
    end

  always@(sign_shift_small_float or sign_big_float) //sum
    begin
      overflow = {1'b0, sign_shift_small_float} + {1'b0, sign_big_float};
    end

  always@(overflow) //extract
    begin
      if(small_sig==1 && big_sig==1)
	begin //negative round
	  sum = overflow[25:1];
	  sum_ex = sum_ex + 1;
	end
      else if(small_sig==0 && big_sig==0)
	begin //positive round
	  if(overflow[24]==1)
	    begin
	      sum = overflow[25:1];
	      sum_ex = sum_ex + 1;
	    end
	  else //if overflow[24]==0
	    begin
	      sum = overflow[24:0];
	    end
	end
      else //one of two sig = 1
	begin
	  if(shift_small_float==big_float)
	    begin
	      sum = 0;
	    end
	  else
	    begin
	      sum = overflow[24:0];
	    end
	end
    end

  always@(sum)
    begin
      if(sum[24]==1)
	begin
	  sum_sig = 1;
	  sum = ~sum + 25'b1;
	end
      else
        begin
	  sum_sig = 0;
	end
      if(sum==0)
	begin
	  sum_sig = 0;
	  sum_ex = 0;
	  sum_fra = 0;
	end
      else
	begin
          while(sum[23]!=1)
	    begin
	      sum  = sum << 1;
	      sum_ex = sum_ex - 1;
	    end
	end
	sum_fra = sum[22:0];
    end
	  
  always@(sum_fra)
    begin
      out = {sum_sig, sum_ex, sum_fra};
    end



endmodule